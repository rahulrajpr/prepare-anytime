# Spark Array, Map, and Struct Functions - Study Material

## 3.8 Array Functions

**1. How do you access array elements using `getItem()` or bracket notation?**
- `df.select(col("array_col").getItem(0))` - using getItem()
- `df.select(col("array_col")[0])` - using bracket notation
- Both methods are equivalent; bracket notation is more concise

**2. What does `array()` function do?**
- Creates arrays from multiple columns
- Example: `array(col("col1"), col("col2"), col("col3"))`
- Combines column values into a single array column

**3. How do you use `array_contains()`?**
- Checks if an array contains a specific element
- Syntax: `array_contains(col("array_col"), "value")`
- Returns boolean (true/false)

**4. What does `array_distinct()` do?**
- Removes duplicate elements from an array
- Returns array with only unique elements
- Preserves original order (first occurrence)

**5. How do you use `array_intersect()`, `array_union()`, `array_except()`?**
- `array_intersect(col1, col2)`: Returns common elements (intersection)
- `array_union(col1, col2)`: Combines arrays, removes duplicates (union)
- `array_except(col1, col2)`: Elements in col1 but not in col2 (difference)

**6. What does `array_join()` do?**
- Concatenates array elements into a single string
- Syntax: `array_join(col("array_col"), delimiter)`
- Example: `array_join(array("a", "b", "c"), ",")` → "a,b,c"

**7. How do you sort array elements using `array_sort()`?**
- Syntax: `array_sort(col("array_col"))`
- Sorts in ascending order by default
- Can use custom comparator with lambda function

**8. What is `array_max()`, `array_min()`, `size()` used for?**
- `array_max()`: Returns maximum element in array
- `array_min()`: Returns minimum element in array
- `size()`: Returns number of elements in array

**9. How do you use `flatten()` for nested arrays?**
- Flattens nested arrays into a single-level array
- Example: `[[1,2], [3,4]]` → `[1,2,3,4]`
- Only flattens one level deep

**10. What does `array_repeat()` function do?**
- Creates array by repeating an element n times
- Syntax: `array_repeat(value, count)`
- Example: `array_repeat("x", 3)` → `["x", "x", "x"]`

**11. How do you use `slice()` to extract a portion of an array?**
- Syntax: `slice(array_col, start, length)`
- Start index is 1-based (not 0-based)
- Returns subarray of specified length

**12. What is `array_position()` used for?**
- Finds the position/index of first occurrence of element
- Syntax: `array_position(col("array_col"), value)`
- Returns 1-based index (0 if not found)

**13. How do you remove elements from an array using `array_remove()`?**
- Removes all occurrences of specified element
- Syntax: `array_remove(col("array_col"), value)`
- Returns new array without the element

**14. What does `shuffle()` do to array elements?**
- Randomly shuffles array elements
- Returns array with elements in random order
- Non-deterministic (different results each time)

**15. How do you use `zip_with()` for element-wise array operations?**
- Applies lambda function to pairs of elements from two arrays
- Syntax: `zip_with(array1, array2, lambda)`
- Example: `zip_with(arr1, arr2, (x, y) => x + y)` for element-wise addition

---

## 3.8.1 Advanced Array Functions & Comparisons

### size() vs cardinality()

**1. Difference between `size()` and `cardinality()`?**
- No functional difference
- Both return the number of elements in array/map

**2. Are `size()` and `cardinality()` functionally identical?**
- **YES** - They produce identical results

**3. When to use `size()` vs `cardinality()`?**
- Personal preference only
- `size()` is more commonly used and intuitive

### Array Sorting Functions

**4. Difference between `reverse()`, `sort_array()`, and `array_sort()`?**
- `reverse()`: Reverses element order
- `sort_array()`: Basic sorting (ascending/descending)
- `array_sort()`: Advanced sorting with custom comparators

**5. What parameters does `reverse()` accept? What does it do?**
- Accepts only array column
- Reverses the order of elements
- No sorting, just reversal

**6. What parameters does `sort_array()` accept? How to control sort order?**
- `sort_array(col, asc=True)` or `sort_array(col, asc=False)`
- Second parameter controls ascending (True) or descending (False)
- Simple sorting only

**7. What parameters does `array_sort()` accept? What makes it unique?**
- `array_sort(col)` or `array_sort(col, comparator_lambda)`
- Unique: Supports custom lambda comparator functions
- More flexible than sort_array()

**8. Can you use custom sorting logic with `sort_array()`? With `array_sort()`?**
- `sort_array()`: **NO** - Only ascending/descending
- `array_sort()`: **YES** - Supports custom lambda comparators

**9. When to use `sort_array()` vs `array_sort()`?**
- `sort_array()`: Simple ascending/descending sorts
- `array_sort()`: Complex sorting logic or custom comparisons

### aggregate() vs reduce()

**10. What does `aggregate()` function do on arrays?**
- Aggregates array elements using custom logic
- Reduces array to single value
- Similar to fold operation in functional programming

**11. What parameters does `aggregate()` accept?**
- `aggregate(array, start, merge, finish)`
- `start`: Initial value/accumulator
- `merge`: Lambda to combine accumulator with each element
- `finish`: Optional lambda to transform final result

**12. Difference between `aggregate()` and `reduce()`?**
- No functional difference
- Just different names for same operation

**13. Are `aggregate()` and `reduce()` functionally identical?**
- **YES** - Completely interchangeable

**14. Which name is SQL standard: `aggregate()` or `reduce()`?**
- `aggregate()` is SQL standard
- `reduce()` is more common in functional programming

### Array Concatenation

**15. What does `concat()` do for arrays? Can it handle multiple arrays?**
- Concatenates/merges multiple arrays into one
- **YES** - Can handle 2 or more arrays
- Example: `concat(arr1, arr2, arr3)`

### Element Access Functions

**16. Difference between `element_at()` and `try_element_at()`?**
- `element_at()`: Throws error on invalid index
- `try_element_at()`: Returns NULL on invalid index (safe version)

**17. What happens when `element_at()` tries to access non-existent index?**
- Throws exception/error
- Query fails

**18. What does `try_element_at()` return for non-existent indices?**
- Returns NULL
- Query continues without error

**19. When to use `try_element_at()` instead of `element_at()`?**
- When index might be invalid
- When you want to avoid errors
- When NULL is acceptable fallback

### Predicate Functions

**20. What does `exists()` function do on arrays?**
- Tests if at least one element satisfies condition
- Syntax: `exists(array, lambda)`
- Returns true if any element matches

**21. What does `forall()` function do on arrays?**
- Tests if all elements satisfy condition
- Syntax: `forall(array, lambda)`
- Returns true only if every element matches

**22. Difference between `exists()` and `forall()`?**
- `exists()`: ANY element matches (OR logic)
- `forall()`: ALL elements match (AND logic)

**23. Do `exists()` and `forall()` short-circuit? What does this mean?**
- **YES** - They short-circuit
- `exists()`: Stops at first true
- `forall()`: Stops at first false
- Improves performance by avoiding unnecessary checks

### Higher-Order Functions

**24. What does `filter()` function do on arrays?**
- Filters array elements based on condition
- Syntax: `filter(array, lambda)`
- Returns new array with only matching elements

**25. Difference between `filter()` and `exists()`?**
- `filter()`: Returns filtered array (subset of elements)
- `exists()`: Returns boolean (true/false)
- Different purposes and return types

**26. How is filtering arrays different from filtering DataFrames?**
- Array filter: Works on elements within a single array column
- DataFrame filter: Works on entire rows
- Different scopes of operation

**27. What does `transform()` function do on arrays?**
- Transforms each array element using lambda function
- Syntax: `transform(array, lambda)`
- Returns new array with transformed elements

**28. What parameters does `transform()` lambda accept?**
- `(element)` - just the element
- `(element, index)` - element and its index (0-based)
- Index parameter is optional

### Array Zipping Functions

**29. What does `arrays_zip()` function do?**
- Combines multiple arrays into array of structs
- Each struct contains one element from each input array
- Creates columnar structure

**30. What does `zip_with()` function do?**
- Combines two arrays using custom lambda function
- Element-wise operation
- More flexible than arrays_zip()

**31. Difference between `arrays_zip()` and `zip_with()`?**
- `arrays_zip()`: Creates structs, multiple arrays, no lambda
- `zip_with()`: Uses lambda, only 2 arrays, custom output

**32. How many arrays can `arrays_zip()` handle?**
- Multiple arrays (2 or more)
- No strict limit

**33. How many arrays can `zip_with()` handle?**
- Exactly 2 arrays only

**34. What output structure does `arrays_zip()` create?**
- Array of structs
- Each struct has fields named after input positions (0, 1, 2, etc.)

**35. Can you customize the output with `arrays_zip()`?**
- **NO** - Fixed struct output format
- Cannot customize field names or transformation logic

**36. Does `zip_with()` require a lambda function?**
- **YES** - Lambda function is mandatory
- Defines how to combine elements

**37. How do `arrays_zip()` and `zip_with()` handle arrays of different lengths?**
- `arrays_zip()`: Uses NULL for missing elements in shorter arrays
- `zip_with()`: Typically truncates to shortest array length (implementation dependent)

---

## 3.9 Map Functions

**1. How do you create a map using `map()` or `map_from_arrays()`?**
- `map()`: `map(key1, val1, key2, val2, ...)` - alternating keys and values
- `map_from_arrays()`: `map_from_arrays(keys_array, values_array)` - from two arrays

**2. How do you access map values using `getItem()` or bracket notation?**
- `col("map_col").getItem("key")` - using getItem()
- `col("map_col")["key"]` - using bracket notation
- Both are equivalent

**3. What does `map_keys()` and `map_values()` return?**
- `map_keys()`: Returns array of all keys in map
- `map_values()`: Returns array of all values in map

**4. How do you use `map_concat()` to merge maps?**
- Syntax: `map_concat(map1, map2, ...)`
- Merges multiple maps into one
- Later maps override values for duplicate keys

**5. What does `map_from_entries()` do?**
- Converts array of structs to map
- Each struct must have "key" and "value" fields
- Inverse of map entries explosion

**6. How do you explode maps using `explode()`? What columns does it create?**
- Syntax: `df.select(explode(col("map_col")))`
- Creates two columns: `key` and `value`
- One row per key-value pair

**7. What is `map_filter()` used for?**
- Filters map entries based on condition
- Syntax: `map_filter(map_col, lambda)`
- Returns new map with only matching entries

**8. How do you get the size of a map using `size()`?**
- Syntax: `size(col("map_col"))`
- Returns number of key-value pairs in map

---

## 3.9.1 Map Functions Deep Dive & Comparisons

### filter() vs map_filter()

**1. Difference between `filter()` and `map_filter()`?**
- `filter()`: Works on arrays
- `map_filter()`: Works on maps
- Different data structure types

**2. What input types do `filter()` vs `map_filter()` accept?**
- `filter()`: Array column
- `map_filter()`: Map column

**3. How many lambda parameters does `map_filter()` accept?**
- 2 parameters: `(key, value)`
- Both key and value available in condition

**4. What does `map_filter()` return?**
- Returns filtered map
- Maintains map structure with subset of entries

### transform Functions Comparison

**5. What does `transform()` do for arrays?**
- Transforms each array element using lambda
- Returns new array with same size
- Element-wise transformation

**6. What does `transform_keys()` do for maps?**
- Transforms map keys using lambda
- Values remain unchanged
- Returns new map with transformed keys

**7. What does `transform_values()` do for maps?**
- Transforms map values using lambda
- Keys remain unchanged
- Returns new map with transformed values

**8. Compare `transform()` vs `transform_keys()` vs `transform_values()` - when to use each?**
- `transform()`: Transform array elements
- `transform_keys()`: Transform map keys only
- `transform_values()`: Transform map values only
- Choose based on data structure and what needs changing

**9. What lambda parameters does `transform()` accept?**
- Arrays: `(element)` or `(element, index)`

**10. What lambda parameters do `transform_keys()` and `transform_values()` accept?**
- `transform_keys()`: `(key, value)` - both available
- `transform_values()`: `(key, value)` - both available
- Even though only one is transformed, both are accessible

**11. Does `transform()` change the size of an array?**
- **NO** - Same number of elements
- Only changes element values, not count

**12. Does `transform_keys()` or `transform_values()` change the size of a map?**
- **NO** - Same number of entries
- Only changes keys or values, not entry count

**13. What changes when you use `transform_keys()` - keys or values?**
- Only keys change
- Values remain unchanged

**14. What changes when you use `transform_values()` - keys or values?**
- Only values change
- Keys remain unchanged

### Map Functions vs Array Functions

**15. Can you use `size()` and `cardinality()` on maps?**
- **YES** - Both work on maps
- Return number of key-value pairs
- Functionally identical for maps too

**16. Does `element_at()` work on maps? How?**
- **YES** - Works on maps
- Syntax: `element_at(map_col, key)`
- Returns value for given key
- Throws error if key doesn't exist

**17. Does `try_element_at()` work on maps?**
- **YES** - Safe version for maps
- Returns NULL if key doesn't exist
- No error thrown

---

## 3.10 Struct Functions

**1. How do you access struct fields using dot notation or `getField()`?**
- Dot notation: `col("struct_col.field_name")` or `col("struct_col").field_name`
- getField(): `col("struct_col").getField("field_name")`
- Both are equivalent

**2. What does `struct()` function do?**
- Creates struct from multiple columns
- Syntax: `struct(col("col1"), col("col2").alias("name2"))`
- Combines columns into nested structure

**3. How do you flatten struct columns?**
- Use `col("struct_col.*")` to expand all fields
- Or select individual fields: `col("struct_col.field1"), col("struct_col.field2")`
- Promotes nested fields to top-level columns

**4. Can you use `withColumn()` to modify a field within a struct?**
- **NO** - Not directly
- Must recreate entire struct with modified field
- Use `struct()` with mix of original and new field values

**5. How do you select specific fields from a nested struct?**
- Use dot notation: `select("struct_col.field1", "struct_col.field2")`
- Or: `select(col("struct_col.field1"), col("struct_col.field2"))`
- Can select subset of struct fields
